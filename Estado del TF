#include <iostream> // Necesario para Operadores de entrada y salida de datos
#include <conio.h> // Necesario para getch()
#include <cstdlib> // Necesario para system("cls")
#include <ctime> // Necesario para srand y rand
#include <windows.h> // Necesario para HideCursor y SetColor
#include <string>

using namespace std;

const int width = 60; // Ancho del tablero
const int height = 25; // Alto del tablero
int posX = width / 2; // Posición inicial X del muñeco O
int posY = height / 2; // Posición inicial Y del muñeco O
const int numCharacters = 10; // Número total de muñecos

bool validPosition; // Booleano para controlar la validacion de posicion

int TutorVisits; // Visitas al tutor
int EnemyVisits; // Visitas al enemigo
float Points = 25; // Puntaje del jugador

string Espera = "Presiona cualquier tecla para continuar..."; // Tiempo de espera
string Despedida = "El juego ha finalizado";

char board[height][width]; // Tablero de juego

/*
Mundos
*/
char Board_1[height][width] = {
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1},
    {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

char Board_2[height][width] = {
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1},
    {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1},
    {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1},
    {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1},
    {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1},
    {1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1},
    {1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1},
    {1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1},
    {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1},
    {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

char Board_3[height][width] = {
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1},
    {1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1},
    {1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1},
    {1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1},
    {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
};

/*
Impresion de Mundos
*/
void PrintBoard_1(char board[height][width]) {
    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            if (board[i][j] == 1) {
                cout << "# "; // Bloque de color rojo
            }
            else {
                cout << "  ";
            }
        }
        cout << endl;
    }
}

void PrintBoard_2(char board[height][width]) {
    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            if (board[i][j] == 1) {
                cout << "# "; // Bloque de color verde
            }
            else {
                cout << "  ";
            }
        }
        cout << endl;
    }
}

void PrintBoard_3(char board[height][width]) {
    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            if (board[i][j] == 1) {
                cout << "# "; // Bloque de color amarillo
            }
            else {
                cout << "  ";
            }
        }
        cout << endl;
    }
}

/*
Funciones Auxiliares
*/
void setColor(int textColor, int bgColor) {
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hConsole, (bgColor << 4) | textColor);
}

void resetColor() {
    setColor(7, 0);
}

void gotoxy(int x, int y) {
    COORD coord;
    coord.X = x;
    coord.Y = y;
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);
}

void clearScreen() {
    system("cls");
}

void hideCursor() {
    // Estructura para almacenar la información del cursor
    CONSOLE_CURSOR_INFO cursorInfo;

    // Manejador de la consola
    HANDLE consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);

    // Obtiene la información actual del cursor
    GetConsoleCursorInfo(consoleHandle, &cursorInfo);

    // Oculta el cursor estableciendo su visibilidad en false
    cursorInfo.bVisible = false;

    // Establece la información del cursor en la consola
    SetConsoleCursorInfo(consoleHandle, &cursorInfo);
}

int randnum(int min, int max) {
    return min + rand() % (max - min + 1);
}

/*
Heroe
*/
void PuntajeHeroe(int x, int y, int points) {
    gotoxy(x, y);
    cout << "Puntaje del Jugador: " << points;
    gotoxy(0, 0);
}

void Hero(int level, int x, int y, string name) {
    gotoxy(x, y);
    cout << "Has llegado al Mundo " << (level + 1);
    gotoxy(x-16, y+1);
    cout << "Querido Heroe " << name << ", ¿podra liberarnos de la ignorancia?";
    gotoxy(0, 0);
}

void NumVisitsTutor(int x, int y, int TutorVisits) {
    gotoxy(x, y);
    cout << "Numero de visitas al Tutor: " << TutorVisits;
    gotoxy(0, 0);
}

void NumVisitsEnemy(int x, int y, int EnemyVisits) {
    gotoxy(x, y);
    cout << "Numero de visitas al Enemigo: " << EnemyVisits;
    gotoxy(0, 0);
}

/*
Efectos de Mensaje
*/
void printGradually(const string& message, int delay) {
    for (char c : message) {
        cout << c << flush; // Asegura que el carácter se imprima inmediatamente
        Sleep(delay); // Retraso
    }
    cout << endl; // Salto de línea al final del mensaje
}

void printBlinkingText(const string& text, int x, int y) {
    while (true) {
        if (_kbhit()) {
            // Si se ha presionado una tecla, detener el parpadeo y salir del bucle
            break;
        }
        gotoxy(x, y);
        cout << text << flush; // Imprimir texto
        Sleep(500); // Retraso

        // Mover el cursor atrás y borrar el texto
        cout << "\033[1K\r" << flush; // Código de escape ANSI para borrar texto
        Sleep(500); // Retraso
    }
}

/*
Movimiento de los Tutores y Enemigos
*/
void moveCharacter(char board[height][width], int& posY, int& posX) {
    int move = rand() % 4;
    switch (move) {
    case 0: if (board[posY - 1][posX] == ' ') posY--; break;
    case 1: if (board[posY][posX - 1] == ' ') posX--; break;
    case 2: if (board[posY + 1][posX] == ' ') posY++; break;
    case 3: if (board[posY][posX + 1] == ' ') posX++; break;
    }
}

void moveCharacters(char board[height][width], int posYChars[], int posXChars[]) {
    for (int i = 0; i < numCharacters; ++i) {
        moveCharacter(board, posYChars[i], posXChars[i]);
    }
}

/*
Tutoriales
*/
void showPythagorasCuriousThings() {
    clearScreen();
    int input;
    cout << "Ingresa un numero del 1 al 7:" << endl;
    input = _getch() - '0'; // Convierte el caracter a entero
    switch (input) {
        cout << "Ahora un dato curioso sobre Pitagoras:" << endl;
    case 1:
        cout << "El 'Padre de los Numeros':" << endl;
        cout << "Sobre su atribucion como el 'Padre de los Numeros' debido a su fundamental contribucion a las matematicas." << endl;
        cout << "El famoso Teorema de Pitagoras se sigue ensenando hasta el dia de hoy." << endl;
        cout << "Sigue la Matematica con pasion en este mundo lleno de descubrimientos" << endl;
        break;
    case 2:
        cout << "Fundador de una Escuela Secreta:" << endl;
        cout << "Sobre su fundacion de una escuela en Crotona, donde sus seguidores, aprendian con el, Matematicas, Filosofia y Musica." << endl;
        cout << "La escuela funcionaba casi como una sociedad secreta con sus propios ritos y reglas." << endl;
        cout << "Aun tienes mucho por descubrir en este mundo de las Matematicas" << endl;
        break;
    case 3:
        cout << "Amor por la Musica:" << endl;
        cout << "Pitagoras creia que la Musica y las Matematicas estaban conectadas. Descubrio que las Matematicas podian representar tonos musicales." << endl;
        cout << "Este hallazgo se convirtio en la base de la teoria musical." << endl;
        cout << "¿Quien lo diria?, Pitagoras pudo ser cantante" << endl;
        break;
    case 4:
        cout << "Creencia en la Reencarnacion:" << endl;
        cout << "Pitagoras creia en la Reencarnacion, la idea del renacer, el alma entrando a un nuevo cuerpo." << endl;
        cout << "Pensaba que las almas podian reencarnar tanto en humanos como animales." << endl;
        cout << "Animate, podrias ser el siguiente Pitagoras" << endl;
        break;
    case 5:
        cout << "El Numero 10 como Sagrado:" << endl;
        cout << "Para Pitagoras y sus seguidores, el numero 10 era sagrado y perfecto." << endl;
        cout << "Lo representaban con un simbolo llamado tetraktys, que es un triangulo formado por diez puntos dispuestos en cuatro filas." << endl;
        cout << "Diez de diez" << endl;
        break;
    case 6:
        cout << "Primero en llamarse Filosofo:" << endl;
        cout << "Se le atribuye haber sido el primero en usar la palabra 'filosofo' para describirse a sí mismo." << endl;
        cout << "La historia detras de este término es interesante y revela mucho sobre la vision que Pitagoras tenía de la vida y el conocimiento." << endl;
        cout << "Bastante inspirador" << endl;
        break;
    case 7:
        cout << "Los Numeros Tienen Personalidades:" << endl;
        cout << "Pitagoras y sus seguidores creian que los numeros tenian personalidades y cualidades propias." << endl;
        cout << "Por ejemplo, pensaban que el numero 1 era masculino y creativo, mientras que el numero 2 era femenino y pasivo." << endl;
        cout << "¿Que numeros seriamos?" << endl;
        break;
    default:
        clearScreen();
        showPythagorasCuriousThings();
    }
    printBlinkingText(Espera, 0, 7);
    _getch();
}

void showPythagorasTheorem() {
    clearScreen();
    int input;
    cout << "Ingresa un numero del 1 al 7:" << endl;
    input = _getch() - '0'; // Convierte el caracter a entero
    switch (input) {
        cout << "Ahora un dato sobre la utilidad del Teorema de Pitagoras:" << endl;
    case 1:
        cout << "Hipotenusa:" << endl;
        cout << "La hipotenusa es siempre el lado opuesto al ángulo recto en un triangulo rectangulo y es el lado más largo." << endl;
        cout << "La formula a^2 + b^2 = c^2 permite calcular la longitud de la hipotenusa si se conocen las longitudes de los otros dos lados." << endl;
        cout << "¿Te imaginas cuantas veces ha sido usado el teorema?" << endl;
        break;
    case 2:
        cout << "No fue descubierto solo por Pitagoras:" << endl;
        cout << "Aunque el teorema lleva su nombre, hay evidencia de que el conocimiento de esta relacion matematica existia en otras culturas antiguas." << endl;
        cout << "Sin embargo, Pitagoras es a menudo acreditado con su primera demostracion formal." << endl;
        cout << "Vaya, el Teorema de Pitagoras, no provino de Pitagoras" << endl;
        break;
    case 3:
        cout << "Aplicaciones en la vida diaria:" << endl;
        cout << "El teorema de Pitagoras se utiliza en muchas areas practicas, como la construccion, la navegacion y la arquitectura." << endl;
        cout << "Por ejemplo, los arquitectos y constructores lo usan para asegurarse de que los angulos de las esquinas sean rectos." << endl;
        cout << "Tal vez, tu, futuro Ingeniero, lo vayas a necesitar" << endl;
        break;
    case 4:
        cout << "Relacion con los triangulos rectangulos:" << endl;
        cout << "El teorema de Pitágoras solo se aplica a los triangulos rectangulos, es decir, aquellos que tienen un angulo de 90 grados." << endl;
        cout << "La formula relaciona las longitudes de los lados del triangulo, donde c es la hipotenusa (el lado mas largo), y a y b son los otros lados" << endl;
        cout << "Util, ¿verdad?" << endl;
        break;
    case 5:
        cout << "Pruebas diversas:" << endl;
        cout << "Hay mas de 370 pruebas conocidas del teorema de Pitagoras, incluyendo algunas geometricas, algebraicas y por reduccion al absurdo." << endl;
        cout << "Uno de los mas famosos que ofrecio una prueba fue el presidente de los Estados Unidos, James Garfield." << endl;
        cout << "¿Podrias demostrarlo?" << endl;
        break;
    case 6:
        cout << "Pitagoricos y numeros enteros:" << endl;
        cout << "Los seguidores de Pitagoras, conocidos como los pitagoricos, estaban muy interesados en los numeros y descubrieron que en algunos triangulos rectangulos, los tres lados pueden ser numeros enteros." << endl;
        cout << "Estos conjuntos de numeros se conocen como triadas pitagoricas. Un ejemplo clasico es (3, 4, 5), donde 3^2 + 4^2 = 5^2 (9 + 16 = 25)" << endl;
        cout << "Muchos nos hemos convertido en Pitagoricos" << endl;
        break;
    case 7:
        cout << "Teorema inverso:" << endl;
        cout << "Si en un triangulo, el cuadrado de un lado es igual a la suma de los cuadrados de los otros dos lados." << endl;
        cout << "Entonces el triangulo es un triangulo rectangulo. Esto se utiliza a menudo para verificar si un triangulo es rectangulo." << endl;
        cout << "Hay mas utilidades del Teorema de Pitagoras" << endl;
        break;
    default:
        clearScreen();
        showPythagorasTheorem();
    }
    printBlinkingText(Espera, 0, 7);
    _getch();
}

void showPythagorasVectors() {
    clearScreen();
    int input;
    cout << "Ingresa un numero del 1 al 7:" << endl;
    input = _getch() - '0'; // Convierte el caracter a entero
    switch (input) {
        cout << "Ahora un dato sobre el Teorema de Pitagoras en los Vectores:" << endl;
    case 1:
        cout << "Magnitud de un Vector:" << endl;
        cout << "La magnitud (o longitud) de un vector V se puede encontrar utilizando el teorema de Pitagoras." << endl;
        cout << "La magnitud se calcula como: |V| = sqrt(V_x^2 + V_y^2)" << endl;
        cout << "Asi es como desarrollamos la magnitud de un vector" << endl;
        break;
    case 2:
        cout << "Distancia entre Dos Puntos:" << endl;
        cout << "El teorema de Pitagoras tambien se utiliza para calcular la distancia entre dos puntos en el plano. Si tienes dos puntos A(x_1, y_1) y B(x_2, y_2)." << endl;
        cout << "La distancia entre estos dos puntos se calcula como: |AB| = sqrt((x_2-x_1)^2 + (y_2-y_1)^2)" << endl;
        cout << "Ahora sabes mas sobre el el uso del Teorema de Pitagoras en vectores" << endl;
        break;
    case 3:
        cout << "Vectores en el Espacio:" << endl;
        cout << "Para un vector en el espacio tridimensional V = (V_x, V_y, V_z), el teorema se extiende de manera similar:" << endl;
        cout << "|V| = sqrt(V_x^2 + V_y^2 + V_z^2)" << endl;
        cout << "Una de las otras utilidades del Teorema de Pitagoras" << endl;
        break;
    case 4:
        cout << "Suma de Vectores:" << endl;
        cout << "Cuando sumamos dos vectores que son perpendiculares entre si, la magnitud del vector resultante se puede encontrar usando el teorema de Pitagoras." << endl;
        cout << "Si A y B son perpendiculares, R = A + B. La magnitud de R se puede calcular como: |R| = sqrt(|A|^2 + |B|^2)" << endl;
        cout << "Mas utilidades del Teorema de Pitagoras, sigue asi" << endl;
        break;
    case 5:
        cout << "Aplicaciones en Fisica:" << endl;
        cout << "En fisica, el teorema de Pitagoras es fundamental para resolver problemas relacionados con:" << endl;
        cout << "Desplazamiento, Fuerza Resultante, Velocidad y Aceleracion" << endl;
        cout << "Podemos medir ahora en la Fisica" << endl;
        break;
    case 6:
        cout << "Geometria y Trigonometria:" << endl;
        cout << "El teorema de Pitagoras es la base para muchas formulas trigonometricas y es utilizado para derivar las relaciones entre las funciones trigonometricas en un triangulo rectangulo." << endl;
        cout << "Ademas, se usa para resolver problemas en geometria analitica y algebra vectorial." << endl;
        cout << "El teorema de Pitagoras es profundo" << endl;
        break;
    case 7:
        cout << "Norma Euclidiana en el Espacio n-Dimensional" << endl;
        cout << "Para un vector V en un espacio n - dimensional, representado como V = (V_1, V_2, ... , V_n) la norma euclidiana se calcula extendiendo el teorema de Pitagoras a mas dimensiones" << endl;
        cout << "La formula general es: |V| = sqrt(V_1^2 + V_2^2 + ... + V_n^2)" << endl;
        cout << "Bastante utilizado en diferentes ramas del conocimiento" << endl;
        break;
    default:
        clearScreen();
        showPythagorasVectors();
    }
    printBlinkingText(Espera, 0, 7);
    _getch();
}

void showPythagorasTutorial_A() {
    clearScreen();
    int input;
    cout << "Ahora un Tutorial sobre Pitagoras" << endl;
    cout << "Selecciona que tutorial deseas:" << endl;
    cout << "1. Datos Curiosos sobre Pitagoras" << endl;
    cout << "2. Usos del Teorema de Pitagoras en el triangulo" << endl;
    cout << "3. El Teorema de Pitagoras en los vectores" << endl;
    input = _getch() - '0'; // Convierte el caracter a entero
    switch (input) {
    case 1: showPythagorasCuriousThings();
        break;
    case 2: showPythagorasTheorem();
        break;
    case 3: showPythagorasVectors();
        break;
    default: 
        clearScreen();
        showPythagorasTutorial_A();
    }
}

void showEquationsCuriousThings() {
    clearScreen();
    int input;
    cout << "Selecciona un numero del 1 al 7:" << endl;
    input = _getch() - '0'; // Convierte el caracter a entero
    switch (input) {
        cout << "Ahora un dato curioso sobre las ecuaciones:" << endl;
    case 1:
        cout << "Origen Antiguo" << endl;
        cout << "Las ecuaciones de primer grado tienen una historia muy antigua." << endl;
        cout << "Los babilonios ya resolvían ecuaciones lineales alrededor del 1900 a.C. utilizando metodos geometricos y aritmeticos." << endl;
        cout << "Hace mucho tiempo" << endl;
        break;
    case 2:
        cout << "Simplicidad y Versatilidad" << endl;
        cout << "A pesar de su simplicidad, las ecuaciones de primer grado son fundamentales en matematicas y ciencias." << endl;
        cout << "Pueden describir una amplia variedad de situaciones, desde problemas financieros hasta relaciones fisicas basicas." << endl;
        cout << "Hasta para calcular tus gastos" << endl;
        break;
    case 3:
        cout << "Representacion Grafica" << endl;
        cout << "En un sistema de coordenadas cartesianas, la grafica de una ecuación de primer grado con dos variables y = mx + b es una linea recta." << endl;
        cout << "Aquí, m representa la pendiente de la línea y b el punto donde la línea intercepta el eje y." << endl;
        cout << "Interesante ¿verdad?" << endl;
        break;
    case 4:
        cout << "Propiedades Importantes" << endl;
        cout << "La solución de una ecuacion de primer grado siempre es unica." << endl;
        cout << "Esto significa que para cualquier ecuacion de la forma ax + b = 0, siempre habra una unica solucion para x (si a es diferente de 0)." << endl;
        cout << "Sigue asi" << endl;
        break;
    case 5:
        cout << "Metodos de Resolucion" << endl;
        cout << "Las ecuaciones de primer grado pueden resolverse de varias maneras, incluyendo:" << endl;
        cout << "Despeje (mover terminos de un lado a otro para aislar la variable), Graficamente (interseccion de lineas) y metodo de igualacion, sustitucion y eliminacion." << endl;
        cout << "Ahora sabes la resolucion de ecuaciones" << endl;
        break;
    case 6:
        cout << "Aplicaciones Practicas" << endl;
        cout << "Se utilizan en finanzas para calcular intereses simples y compuestos. En fisica, para describir relaciones basicas como la velocidad constante (v = d/t)." << endl;
        cout << "En economia, para encontrar puntos de equilibrio entre oferta y demanda." << endl;
        cout << "Futuro Ingeniero, lo necesitaras" << endl;
        break;
    case 7:
        cout << "Simbolismo Historico" << endl;
        cout << "Los matematicos antiguos usaban diferentes metodos simbolicos para representar y resolver ecuaciones lineales." << endl;
        cout << "Por ejemplo, los arabes utilizaron el termino 'resto' para describir la ecuacion de balanceo, de ahi el termino 'al - jabr', que eventualmente evoluciono en la palabra 'algebra'." << endl;
        cout << "¿Sabes de donde deriva tu nombre?" << endl;
        break;
    default:
        clearScreen();
        showEquationsCuriousThings();
    }
    printBlinkingText(Espera, 0, 7);
    _getch();
}

void showEquationsUtility() {
    clearScreen();
    int input;
    cout << "Selecciona un numero del 1 al 7:" << endl;
    input = _getch() - '0'; // Convierte el caracter a entero
    switch (input) {
        cout << "Ahora un dato sobre la utilidad de las ecuaciones:" << endl;
    case 1:
        cout << "Modelado de Situaciones Reales" << endl;
        cout << "Las ecuaciones se utilizan para modelar y resolver problemas en diversas disciplinas como:" << endl;
        cout << "Fisica, quimica, biologia, economia y ingenieria." << endl;
        cout << "Bastante util" << endl;
        break;
    case 2:
        cout << "Prediccion y Pronostico" << endl;
        cout << "En economia, las ecuaciones ayudan a predecir tendencias de mercado y comportamientos financieros." << endl;
        cout << "Muchos utilizados a traves de modelos econometricos." << endl;
        cout << "Se pueden predecir muchas mas cosas" << endl;
        break;
    case 3:
        cout << "Optimizacion" << endl;
        cout << "En logistica y negocios, las ecuaciones se usan para optimizar rutas de transporte, produccion y distribucion." << endl;
        cout << "Minimizando costos y maximizando eficiencia." << endl;
        cout << "Vaya, deberiamos hacerlo" << endl;
        break;
    case 4:
        cout << "Ingenieria y Diseno" << endl;
        cout << "Los ingenieros utilizan ecuaciones para diseñar:" << endl;
        cout << "Estructuras, circuitos electricos, sistemas mecanicos y otros proyectos complejos." << endl;
        cout << "¡Puedes crear puentes, robots y mucho mas!" << endl;
        break;
    case 5:
        cout << "Medicina y Biologia" << endl;
        cout << "Las ecuaciones modelan:" << endl;
        cout << "La propagacion de enfermedades, el crecimiento de poblaciones celulares y la dinamica de sistemas biologicos." << endl;
        cout << "¡Ayuda a salvar vidas y descubrir curas!" << endl;
        break;
    case 6:
        cout << "Ciencias Sociales" << endl;
        cout << "Se emplean para analizar datos y hacer inferencias en sociologia, psicologia y ciencias politicas." << endl;
        cout << "Ayudando a entender y predecir comportamientos humanos y sociales." << endl;
        cout << "¡Descubre por que las personas hacen lo que hacen!" << endl;
        break;
    case 7:
        cout << "Tecnologia de la Informacion" << endl;
        cout << "En informatica, las ecuaciones se utilizan en algoritmos, criptografia y analisis de datos." << endl;
        cout << "Mejorando la eficiencia y seguridad de los sistemas informaticos." << endl;
        cout << "¡Imagina poder crear tu propio videojuego o una app increíble!" << endl;
        break;
    default:
        clearScreen();
        showEquationsUtility();
    }
    printBlinkingText(Espera, 0, 7);
    _getch();
}

void showEquationsHistory() {
    clearScreen();
    int input;
    cout << "Selecciona un numero del 1 al 7:" << endl;
    input = _getch() - '0'; // Convierte el caracter a entero
    switch (input) {
        cout << "Ahora un dato sobre la historia de las ecuaciones:" << endl;
    case 1:
        cout << "Babilonia" << endl;
        cout << "Los babilonios (alrededor de 2000 a.C.) resolvian ecuaciones cuadraticas y cubicas utilizando metodos aritmeticos y geometricos." << endl;
        cout << "Tambien desarrollaron tablas matematicas, como las de multiplicación y de logaritmos, que facilitaban sus calculos." << endl;
        cout << "¡Descubre como puedes desarrollar tus tablas!" << endl;
        break;
    case 2:
        cout << "Grecia Antigua" << endl;
        cout << "Euclides y Diofanto hicieron contribuciones significativas al algebra y a la teoria de ecuaciones en el siglo III a.C." << endl;
        cout << "Ademas, los griegos introdujeron el concepto de demostracion matematica formal, que sento las bases para el desarrollo de la geometria y el algebra." << endl;
        cout << "¡Animate, podrias sentar las bases de la era Revolucionaria!" << endl;
        break;
    case 3:
        cout << "Matematicos Arabes" << endl;
        cout << "Al-Juarismi, un matematico persa del siglo IX." << endl;
        cout << "Escribio un libro que sistematizo la resolucion de ecuaciones lineales y cuadraticas, dando origen a la palabra 'algebra'." << endl;
        cout << "Tal vez, tu siguiente libro sea un exito, ¡no lo dudes!" << endl;
        break;
    case 4:
        cout << "India" << endl;
        cout << "Matematicos como Brahmagupta (siglo VII) desarrollaron metodos para resolver ecuaciones indeterminadas y cuadraticas." << endl;
        cout << "Tambien introdujeron conceptos avanzados en aritmetica y algebra, como el uso del cero y las propiedades de los numeros negativos." << endl;
        cout << "Aprenderas mas cosas sobre los numeros" << endl;
        break;
    case 5:
        cout << "Edad Media" << endl;
        cout << "Los matematicos europeos como Fibonacci (siglo XIII) reintrodujeron el conocimiento arabe y griego en Europa, incluyendo la resolucion de ecuaciones." << endl;
        cout << "Este periodo tambien vio el desarrollo de la algebra simbolica y metodos avanzados de calculo que sentaron las bases para la revolucion matematica en los siglos posteriores." << endl;
        cout << "¡Probablemente crees una nueva secuencia de numeros!" << endl;
        break;
    case 6:
        cout << "Renacimiento" << endl;
        cout << "Durante el Renacimiento, matematicos italianos como Tartaglia y Cardano resolvieron ecuaciones cubicas y cuarticas" << endl;
        cout << "Expandiendo significativamente el campo del algebra." << endl;
        cout << "Bastante motivador" << endl;
        break;
    case 7:
        cout << "Siglo XIX" << endl;
        cout << "La teoria de Galois revoluciono la comprension de las ecuaciones polinomicas y su resolubilidad, sentando las bases para el algebra moderna." << endl;
        cout << "Este periodo tambien presencio avances significativos en el desarrollo de metodos computacionales y aplicaciones practicas de las matematicas en diversas disciplinas cientificas y tecnologicas." << endl;
        cout << "¡Ya cerca a nuestros tiempos!" << endl;
        break;
    default:
        clearScreen();
        showEquationsHistory();
    }
    printBlinkingText(Espera, 0, 7);
    _getch();
}

void showEquationsTutorial_X() {
    clearScreen();
    int input;
    cout << "Ahora un Tutorial sobre Ecuaciones" << endl;
    cout << "Selecciona que tutorial deseas:" << endl;
    cout << "1. Datos Curiosos sobre las Ecuaciones" << endl;
    cout << "2. Usos de las Ecuaciones" << endl;
    cout << "3. Historia de las ecuaciones" << endl;
    input = _getch() - '0'; // Convierte el caracter a entero
    switch (input) {
    case 1: showEquationsCuriousThings();
        break;
    case 2: showEquationsUtility();
        break;
    case 3: showEquationsHistory();
        break;
    default: clearScreen(); showEquationsTutorial_X();
    }
}

/*
Estructura para los Desafios
*/
struct Challenge {
    string challengeText;
    string alternatives[3];
    int correctAnswer;
};

/*
Modelo de Pregunta
*/
void askQuestion(const Challenge& challenge) {
    cout << challenge.challengeText << endl;
    cout << "Opciones:" << endl;
    for (int i = 0; i < 3; ++i) {
        cout << i + 1 << ". " << challenge.alternatives[i] << endl;
    }

    int userChoice;
    while (true) {
        cout << "Ingresa tu respuesta (numero de opcion):" << endl;
        cout << "Si crees no estar listo omite el desafio presionando '0':" << endl;
        userChoice = _getch() - '0'; // Convertir carácter a entero

        if (userChoice == 0) {
            cout << "Desafio omitido." << endl;
            Sleep(1000);
            return;
        }
        else if (userChoice >= 1 && userChoice <= 3) {
            if (userChoice == challenge.correctAnswer) {
                cout << "¡Respuesta correcta!" << endl;
                Points += 6; // Aumentamos el puntaje si la respuesta es correcta
            }
            else {
                cout << "Respuesta incorrecta. La respuesta correcta es la opcion: " << challenge.correctAnswer << endl;
                Points -= 2; // Disminuimos el puntaje si la respuesta es incorrecta
            }
            Sleep(1000);
            return; // Salir de la función después de una respuesta válida
        }
        else {
            cout << "Ingresa una opcion valida" << endl;
            Sleep(1000);
            clearScreen();
            cout << challenge.challengeText << endl;
            cout << "Opciones:" << endl;
            for (int i = 0; i < 3; ++i) {
                cout << i + 1 << ". " << challenge.alternatives[i] << endl;
            }
        }
    }
}

void showChallengePythagorasCuriousThings() {
    srand(time(0));
    clearScreen();

    // Definicion de Desafios
    Challenge pythagorasChallenges[] = {
        {"¿Como es atribuido Pitagoras?",
         {"Pitagorico", "Padre de la biologia", "Padre de los numeros"},
         3},
        {"¿Donde fundo Pitagoras su escuela?",
         {"Venecia", "Crotona", "Roma"},
         2},
        {"¿Que relacion descubrio Pitagoras en la Matematica con la Musica?",
         {"La Matematicas tienen sus propias notas musicales", "Las Matematicas podian representar las ondas musicales", "Las Matematicas no se relacionan con la Musica"},
         2},
        {"¿En que creian Pitagoras y sus seguidores sobre sus almas?",
         {"En la inmortalidad", "En la resurreccion", "En la reencarnacion"},
         3},
        {"¿Que numeros Pitagoras y sus seguidores considerabam sagrado y perfecto?",
         {"10", "3", "7"},
         1},
        {"¿Como se autodenomino Pitagoras a si mismo?",
         {"Filosofo", "Amador", "Arquitecto"},
         1},
        {"¿Como consideraba Pitagoras al numero 1?",
        {"Inteligente y honesto", "Masculino y creativo", "Femenino y pasivo"},
        2},
    };

    int numChallenge = rand() % 7;
    cout << "Bien, escogiste un desafio sobre curiosidades de Pitagoras" << endl;
    cout << "Aqui esta el desafio aleatorio numero " << (numChallenge + 1) << ":" << endl;

    askQuestion(pythagorasChallenges[numChallenge]);
}

void showChallengePythagorasTheorem() {
    srand(time(0));
    clearScreen();

    // Definicion de Desafios
    Challenge pythagorasChallenges[] = {
        {"¿En la formula a^2 + b^2 = c^2, que representa la c?",
         {"Diagonal", "Hipotenusa", "Cateto"},
         2},
        {"¿Fue Pitagoras el primero en descubrir 'El Teorema de Pitagoras'?",
         {"Si, fue Pitagoras", "No, antiguas civilizaciones ya lo habian descubierto", "No, fue Platon"},
         2},
        {"¿En que areas es usado el Teorema de Pitagoras?",
         {"Medicina", "Economia", "Navegacion"},
         3},
        {"¿Cuantos grados debe medir un angulo en un triangulo para ser considerado rectangulo?",
         {"90", "85", "45"},
         1},
        {"Aproximadamente, ¿cuantas pruebas hay del Teorema de Pitagoras?",
         {"Mas de 370", "Menos de 250", "Exactamente 600"},
         1},
        {"¿Como se denominaban a los seguidores de Pitagoras?",
         {"Academicos", "Delirantes", "Pitagoricos"},
         3},
        {"¿Como es usado el Teorema Inverso de Pitagoras?",
        {"Para conocer los angulos exteriores de un triangulo", "Para verificar si un triangulo es rectangulo", "Para verificar si un triangulo es escaleno"},
        2},
    };

    int numChallenge = rand() % 7;
    cout << "Bien, escogiste un desafio sobre el teorema de Pitagoras" << endl;
    cout << "Aqui esta el desafio aleatorio numero " << (numChallenge + 1) << ":" << endl;

    askQuestion(pythagorasChallenges[numChallenge]);
}

void showChallengePythagorasVectors() {
    srand(time(0));
    clearScreen();

    // Definicion de Desafios
    Challenge pythagorasChallenges[] = {
        {"¿Se puede desarrollar la magnitud de un vector usando el teorema de Pitagoras?",
         {"Si", "No, es imposible", "Solo se halla usando ley de senos y cosenos"},
         1},
        {"¿Como es calculada la distancia entre 2 puntos en el plano?",
         {"(x_2 - x_1) + (y_2 - y_1)", "sqrt((x_2 - x_1)^2 + (y_2 - y_1)^2)", "(x_2 * x_1 + y_2 * y_1)^2"},
         2},
        {"¿Como es denotado los componentes de un vector tridimensional?",
         {"a, b, c", "1, 2, 3", "x, y, z"},
         3},
        {"¿Puede saberse la magnitud de un vector resultante de vectores perpendiculares a partir del teorema de Pitagoras?",
         {"No, los angulos deben ser llanos", "Si, sabiendo su perpendicularidad", "No es posible"},
         2},
        {"¿Para que aplicaciones en la Fisica es util el teorema de Pitagoras?",
         {"Peso", "Fuerza Resultante", "Altura"},
         2},
        {"¿En que ambitos de la Geometria y Trigonometria es usado el teorema de Pitagoras?",
        {"Algebra Vectorial", "Arte Moderno", "Aritmetica de Punteros"},
        1},
        {"¿Como se llama a la magnitud de n dimensiones derivado del Teorema de Pitagoras?",
        {"Basicismo", "Norma Neutral", "Norma Euclidiana"},
        3},
    };

    int numChallenge = rand() % 7;
    cout << "Bien, escogiste un desafio sobre vectores en el Pitagoras" << endl;
    cout << "Aqui esta el desafio aleatorio numero " << (numChallenge + 1) << ":" << endl;

    askQuestion(pythagorasChallenges[numChallenge]);
}

void showPythagorasChallenge_W() {
    clearScreen();
    int input;
    cout << "¡Colisionaste con el muneco W!" << endl;
    cout << "Ahora un desafio sobre el Teorema de Pitagoras" << endl;
    cout << "Tendras alternativas en el primer mundo, pero asegurate de responder con la respuesta correcta" << endl;
    cout << "¿Sobre que tema deseas ser desafiado?" << endl;
    cout << "1. Desafio sobre datos Curiosos sobre Pitagoras" << endl;
    cout << "2. Desafio sobre el Teorema de Pitagoras" << endl;
    cout << "3. Desafio sobre el Teorema de Pitagoras en los vectores" << endl;
    input = _getch() - '0';
    switch (input) {
    case 1: showChallengePythagorasCuriousThings();
        break;
    case 2: showChallengePythagorasTheorem();
        break;
    case 3: showChallengePythagorasVectors();
        break;
    default: clearScreen(); showPythagorasChallenge_W();
    }
}

void showChallengeEquationsCuriousThings() {
    srand(time(0));
    clearScreen();

    // Definicion de Desafios
    Challenge equationsChallenges[] = {
        {"¿Desde que anos ya resolvian ecuaciones lineales?",
         {"Desde 900 a. C.", "Desde 1500 a. C.", "Desde 1900 a. C."},
         3},
        {"¿Donde son fundamentales las ecuaciones lineales?",
         {"En Psicologia", "En Informatica", "En Matematicas y Ciencias"},
         3},
        {"¿Como es la forma de la ecuacion de la recta?",
         {"y^2 = x^2 - b", "y = x^2 + x + b", "y = mx + b"},
         3},
        {"¿La ecuacion de primer grado tiene unica solucion?",
         {"Si, tiene unica solucion", "No tiene soluciones", "No, tiene 2 soluciones"},
         1},
        {"¿Cual de las siguientes alternativas es un metodo de resolucion de ecuaciones?",
         {"La potenciacion", "La sustitucion", "La diferencia"},
         2},
        {"¿En que area de laburo se usan las ecuaciones lineales para hallar la velocidad?",
         {"Fisica", "Economia", "Arquitectura"},
         1},
        {"¿De que palabra deriva la palabra 'Algebra'?",
        {"La palabra, no derivo", "Al - jabr", "Jabe-rra"},
        2},
    };

    int numChallenge = rand() % 7;
    cout << "Bien, escogiste un desafio sobre curiosidades de Ecuaciones" << endl;
    cout << "Aqui esta el desafio aleatorio numero " << (numChallenge + 1) << ":" << endl;

    askQuestion(equationsChallenges[numChallenge]);
}

void showChallengeEquationsUtility() {
    srand(time(0));
    clearScreen();

    // Definicion de Desafios
    Challenge equationsChallenges[] = {
        {"¿En que disciplinas el modelado de ecuaciones es util?",
         {"Gastronomia","Ingenieria", "Psicologia"},
         2},
        {"¿En la Economia, que predicen las ecuaciones?",
         {"Tasas de interes", "Eventos naturales", "Patrones migratorios"},
         1},
        {"En logistica y negocios, ¿para que son utilizadas las ecuaciones?",
         {"Para mejorar la satisfaccion del cliente", "Para aumentar la visibilidad de la marca", "Para optimizar rutas de transporte"},
         3},
        {"¿Para que los Ingenieros utilizan las ecuaciones?",
         {"Para modelar sistemas financieros", "Para analizar comportamientos de mercado", "Para disenar estructuras"},
         3},
        {"¿Que modelan las ecuaciones en la Medicina y Biologia?",
         {"Modelan el dinamismo celular", "Predicen la propagacion de enfermedades", "Analizan el comportamiento de grupos sociales"},
         1},
        {"¿Para que se utilizan las ecuaciones en las Ciencias Sociales?",
         {"Para disenar politicas publicas", "Para predecir comportamientos humanos", "Para estudiar fenomenos naturales"},
         2},
        {"¿Para que se utilizan las ecuaciones en los sistemas informaticos?",
         {"Para desarrollar estrategias de marketing", "Para entender el comportamiento del consumidor", "Para optimizar la eficiencia y funcionamiento"},
         3},
    };



    int numChallenge = rand() % 7;
    cout << "Bien, escogiste un desafio sobre la utilidad de las ecuaciones" << endl;
    cout << "Aqui esta el desafio aleatorio numero " << (numChallenge + 1) << ":" << endl;

    askQuestion(equationsChallenges[numChallenge]);
}

void showChallengeEquationsHistory() {
    srand(time(0));
    clearScreen();

    // Definicion de Desafios
    Challenge equationsChallenges[] = {
        {"¿Que desarrollaron los Babilonios en 2000 a.C.?",
         {"Tablas de division", "Tablas de multiplicar", "Tablas de suma"},
         2},
        {"¿Quienes introdujeron el concepto de demostracion matematica formal?",
         {"Los croatas", "Los fariseos", "Los griegos"},
         3},
        {"¿Quien fue el autor del libro que introdujo la palabra 'algebra'?",
         {"Al-Ahly", "Al-Kebab", "Al-Juarismi"},
         3},
        {"¿Quienes introdujeron soluciones a ecuaciones cuadraticas e indeterminadas?",
         {"Los Indios", "Los Americanos", "Los Italianos"},
         1},
        {"¿En que periodo se vio el desarrollo de la Algebra Simbolica?",
         {"Edad Media", "Pentateuco", "Era del Hielo"},
         1},
        {"¿Quien fue uno de los que desarrollo cuarticas y cubicas?",
         {"Isaac Newton", "Cardano", "Leonardo Davinci"},
         2},
        {"¿En que siglo la teoria de Galois revoluciono la Matematica?",
        {"Siglo XX", "Siglo XIX", "Siglo XXI"},
        2},
    };

    int numChallenge = rand() % 7;
    cout << "Bien, escogiste un desafio sobre la historia de las Ecuaciones" << endl;
    cout << "Aqui esta el desafio aleatorio numero " << (numChallenge + 1) << ":" << endl;

    askQuestion(equationsChallenges[numChallenge]);
}

void showEquationsChallenge_K() {
    clearScreen();
    int input;
    cout << "¡Colisionaste con el muneco K!" << endl;
    cout << "Ahora un desafio sobre las Ecuaciones" << endl;
    cout << "Tendras alternativas en el primer mundo, pero asegurate de responder con la respuesta correcta" << endl;
    cout << "¿Sobre que tema deseas ser desafiado?" << endl;
    cout << "1. Desafio sobre datos Curiosos sobre Ecuaciones" << endl;
    cout << "2. Desafio sobre la Utilidad de las Ecuaciones" << endl;
    cout << "3. Desafio sobre la Historia de las Ecuaciones" << endl;
    input = _getch() - '0';
    switch (input) {
    case 1: showChallengeEquationsCuriousThings();
        break;
    case 2: showChallengeEquationsUtility();
        break;
    case 3: showChallengeEquationsHistory();
        break;
    default: clearScreen(); showEquationsChallenge_K();
    }
}

void showPythagorasTutorial() {
    clearScreen();
    int input;
    cout << "Selecciona que Tutoria deseas del 1 al 3:" << endl;
    input = _getch() - '0'; // Convierte el caracter a entero
    switch (input) {
        cout << "Ahora un tutorial sobre el Teorema de Pitagoras:" << endl;
    case 1:
        cout << "Formula" << endl;
        cout << "La formula del teorema de Pitagoras es la siguiente: a^2 + b^2 = c^2" << endl;
        cout << "Donde a y b son catetos y c la Hipotenusa" << endl;
        cout << "Genial, ¿verdad?" << endl;
        break;
    case 2:
        cout << "Identificacion" << endl;
        cout << "Para operar la formula, identifica cuales son los catetos" << endl;
        cout << "A partir de ellos puedes reemplazar, porque ambos catetos al cuadrado resulta la Hipotenusa" << endl;
        cout << "¡Tu puedes!" << endl;
        break;
    case 3:
        cout << "Representacion" << endl;
        cout << "El teorema de Pitagoras siempre aplica a triangulos rectangulos" << endl;
        cout << "Por tanto, en una grafica de un triangulo nota si un angulo mide 90 grados para poder aplicar el teorema de Pitagoras" << endl;
        cout << "¡Lo dominaras!" << endl;
        break;
    default:
        clearScreen();
        showPythagorasTutorial();
    }
    printBlinkingText(Espera, 0, 7);
    _getch();
}

void showEquationsTutorial() {
    clearScreen();
    int input;
    cout << "Selecciona que tutoria deseas del 1 al 3:" << endl;
    input = _getch() - '0'; // Convierte el caracter a entero
    switch (input) {
        cout << "Ahora un tutorial sobre las Ecuaciones:" << endl;
    case 1:
        cout << "Equivalencia" << endl;
        cout << "La esencia de las ecuaciones fundamenta en la conservacion del estado equitativo de valores" << endl;
        cout << "De tal manera, considerando un igualdad, a partir de operacion que no alteren la igualdad de una ecuacion, se podran descubrir valores para cualquier incognita" << endl;
        cout << "¡Tu puedes!" << endl;
        break;
    case 2:
        cout << "Resolucion" << endl;
        cout << "Al realizar operaciones a ambos lados de la ecuacion, la expresion seguira siendo la misma. En la ecuacion 5 = 5, si operas con una misma exxpresion a ambos lados de la ecuacion" << endl;
        cout << "La ecuacion mantendra su valor porque se esta agregando un valor equitativo, hacia una igualdad, no lo altera" << endl;
        cout << "¡Vamos!" << endl;
        break;
    case 3:
        cout << "Ejemplo:" << endl;
        cout << "x + 4 = 10, al restar 4 a ambos lados de la ecuacion resulta x = 6" << endl;
        cout << "x/3 = 10, al multiplicar 3 a ambos lados de la ecuacion resulta x = 30" << endl;
        cout << "¡Genial!" << endl;
        break;
    default:
        clearScreen();
        showEquationsTutorial();
    }
    printBlinkingText(Espera, 0, 7);
    _getch();
}

void showTutorial_H() {
    clearScreen();
    int input;
    cout << "¡Colisionaste con el muneco H!" << endl;
    cout << "Ahora un Tutorial" << endl;
    cout << "Selecciona que tutorial deseas:" << endl;
    cout << "1. Tutorial sobre el Teorema de Pitagoras" << endl;
    cout << "2. Tutorial sobre las Ecuaciones" << endl;
    input = _getch() - '0'; // Convierte el caracter a entero
    switch (input) {
    case 1: showPythagorasTutorial();
        break;
    case 2: showEquationsTutorial();
        break;
    default: clearScreen(); showTutorial_H();
    }
}

void showPythagorasEnemy() {
    srand(time(0));
    clearScreen();

    // Definicion de Desafios
    Challenge pythagorasChallenges[] = {
        {"¿Cuanto es el resultado de 3^2 + 4^2 = x?",
         {"36", "25", "16"},
         2},
        {"¿Como es la formula del teorema de Pitagoras?",
         {"y = mx + b", "No tiene formula", "a^2 + b^2 = c^2"},
         3},
        {"Si un triangulo rectangulo tiene 12 y 5 como catetos, ¿cuanto mide su Hipotenusa?",
         {"No existe", "11", "13"},
         3},
        {"¿Puedo saber la longitud de un cateto, sabiendo la hipotenusa y otro de sus catetos?",
         {"Si", "No hay formula para ello", "No, falta informacion"},
         1},
        {"¿Cual es la formula que determina la longitud de un cateto usando el teorema de Pitagoras?",
         {"c^2 = a^2 + b^2", "b = sqrt(c^2 - a^2)", "Ninguna de las anteriores"},
         2},
        {"¿Fue Pitagoras el primero que descubrio el teorema de Pitagoras?",
         {"No, fue Platon", "Si, fue Pitagoras", "No, antiguas civilizaciones ya lo habian descubierto"},
         3},
        {"¿Cuanto es el resultado de 5^2 + 6^2 = x?",
        {"61", "58", "64"},
        1},
    };

    int numChallenge = rand() % 7;
    cout << "Bien, escogiste un desafio sobre el teorema de Pitagoras" << endl;
    cout << "Aqui esta el desafio aleatorio numero " << (numChallenge + 1) << ":" << endl;

    askQuestion(pythagorasChallenges[numChallenge]);
}

void showEquationsEnemy() {
    srand(time(0));
    clearScreen();

    // Definicion de Desafios
    Challenge equationsChallenges[] = {
        {"¿Cuanto es el resultado de 3 + 4?",
         {"6", "7", "8"},
         2},
        {"¿Cuanto resulta x en x - 5 = 10?",
         {"13", "12", "15"},
         3},
        {"¿Cuanto resulta x en x + 5 = 14?",
        {"No existe", "20", "9"},
         3},
        {"¿Cuanto resulta x en x + 20 = 5?",
         {"-15", "0", "12"},
         1},
        {"¿Cuanto resulta x en x - 5 = 16?",
         {"1", "21", "16"},
         2},
        {"¿Cuanto resulta x en x + 9 = 14?",
         {"10", "16", "5"},
         3},
        {"¿Cuanto resulta x en x - 7 = 20?",
        {"27", "21", "24"},
        1},
    };

    int numChallenge = rand() % 7;
    cout << "Bien, escogiste un desafio sobre las Ecuaciones" << endl;
    cout << "Aqui esta el desafio aleatorio numero " << (numChallenge + 1) << ":" << endl;

    askQuestion(equationsChallenges[numChallenge]);
}

void showChallenge_V() {
    clearScreen();
    int input;
    cout << "¡Colisionaste con el muneco V!" << endl;
    cout << "Ahora un desafio sobre las Ecuaciones" << endl;
    cout << "Tendras desafios por escoger en el segundo Mundo, pero asegurate de responder con la respuesta correcta" << endl;
    cout << "¿Sobre que tema deseas ser desafiado?" << endl;
    cout << "1. Desafios sobre el teorema de Pitagoras" << endl;
    cout << "2. Desafios sobre las ecuaciones" << endl;
    input = _getch() - '0';
    switch (input) {
    case 1: showPythagorasEnemy();
        break;
    case 2: showEquationsEnemy();
        break;
    default: clearScreen(); showChallenge_V();
    }
}

void showFinalChallenge_U() {
    clearScreen();
    int input;
    cout << "¡Colisionaste con el jefe final U!" << endl;
    cout << "Ahora un desafio aleatorio" << endl;

    Challenge FinalBossChallenges[] = {
       {"¿Cuanto es el resultado de 3^2?",
        {"7", "5", "9"},
        3},
       {"En la ecuacion 3x + 7 = 25, ¿cuanto vale x?",
        {"6", "9", "18"},
        1},
       {"Teniendo un triangulo con catetos x y 4, e hipotenusa 17, ¿cuanto vale x?",
        {"", "11", "13"},
        1},
       {"¿Teniendo la siguiente ecuacion, (9x - 7)/18 = 2, ¿cuanto vale x?",
        {"4", "0", "No se puede determinar"},
        1},
       {"¿Cual es la formula que determina la longitud de un cateto usando el teorema de Pitagoras?",
        {"c^2 = a^2 + b^2", "b = sqrt(c^2 - a^2)", "Ninguna de las anteriores"},
        3},
       {"¿Fue Pitagoras el primero que descubrio el teorema de Pitagoras?",
        {"No, fue Platon", "Si, fue Pitagoras", "No, antiguas civilizaciones ya lo habian descubierto"},
        1},
       {"¿Cuanto es el resultado de 5^2 + 6^2 = x?",
       {"61", "58", "64"},
       2},
       {"En la ecuacion 5x - 9 = 0?",
        {"14", "9", "9/5"},
        3},
       {"En la ecuacion 3x + 7 = 25, ¿cuanto vale x?",
        {"6", "9", "18"},
        2},
       {"Teniendo un triangulo con catetos x y 4, e hipotenusa 17, ¿cuanto vale x?",
        {"", "11", "13"},
        2},
       {"¿Teniendo la siguiente ecuacion, (9x - 7)/18 = 2, ¿cuanto vale x?",
        {"4", "0", "No se puede determinar"},
        2},
       {"¿Cuanto vale x en la expresion, 2x = 15?",
        {"12", "30", "15/2"},
        3},
       {"¿?",
        {"No, fue Platon", "Si, fue Pitagoras", "No, antiguas civilizaciones ya lo habian descubierto"},
        1},
       {"¿Cuanto es el resultado de 5^2 + 6^2 = x?",
        {"61", "58", "64"},
       2},
       {"¿Cuanto es el resultado de 3^2?",
        {"7", "5", "9"},
        3},
       {"En la ecuacion 3x + 7 = 25, ¿cuanto vale x?",
        {"6", "9", "18"},
        3},
       {"Teniendo un triangulo con catetos x y 4, e hipotenusa 17, ¿cuanto vale x?",
        {"", "11", "13"},
        2},
       {"¿Teniendo la siguiente ecuacion, (9x - 7)/18 = 2, ¿cuanto vale x?",
        {"4", "0", "No se puede determinar"},
        3},
       {"¿Cual es la formula que determina la longitud de un cateto usando el teorema de Pitagoras?",
        {"c^2 = a^2 + b^2", "b = sqrt(c^2 - a^2)", "Ninguna de las anteriores"},
        1},
       {"¿Fue Pitagoras el primero que descubrio el teorema de Pitagoras?",
        {"No, fue Platon", "Si, fue Pitagoras", "No, antiguas civilizaciones ya lo habian descubierto"},
        2},
    };
    int numChallenge = rand() % 21;
    cout << "Bien, ahora un desafio aleatorio" << endl;
    cout << "Aqui el desafio " << numChallenge + 1 << endl;
    askQuestion(FinalBossChallenges[numChallenge]);
}

void Menu() {
    cout << "";
    cout << "";
    cout << "";
    cout << "";
    cout << "";
    cout << "";
}

void Instructions() {
    cout << "";
    cout << "";
    cout << "";
    cout << "";
    cout << "";
    cout << "";
}

void Welcome() {
    setColor(0, 15);
    gotoxy(36, 11);
    cout << " __  __       _   _       _    _           _     _ "; gotoxy(36,12);
    cout << "|  \\/  |     | | | |     | |  | |         | |   | |"; gotoxy(36, 13);
    cout << "| \\  / | __ _| |_| |_    | |  | | ___  ___| |___| |"; gotoxy(36, 14);
    cout << "| |\\/| |/ _` | __| '_ \\  | |/\\| |/ _ \\| __| |  _  |"; gotoxy(36, 15);
    cout << "| |  | | (_| | |_| | | | | /  \\ |||_||| | | | |_| |"; gotoxy(36, 16);
    cout << "|_|  |_|\\__,_|\\__|_| |_| |__/\\__|\\___/\\_| |_|_____|"; gotoxy(36, 17);
    resetColor();
}

void postCredits(const string& name, int nivel, int x, int y, int calification, int tutorvisits, int enemyvisits) {
    clearScreen();

    gotoxy(x-3, y);
    cout << "Enhorabuena " << name << ", has completado " << nivel << " niveles";

    gotoxy(x, y + 1);
    cout << "Tu calificacion es de " << calification;

    gotoxy(x, y + 2);
    cout << "Has visitado a los personajes:";

    gotoxy(x+1, y+3);
    cout << "Tutores: " << tutorvisits;

    gotoxy(x+1, y+4);
    cout << "Enemigos: " << enemyvisits;

    gotoxy(x+4, y+5);
    cout << "Eres ";

    if (calification < 1) {
        cout << "PRINCIPIANTE";
    }
    else if (calification >= 1 && calification < 2) {
        cout << "REGULAR";
    }
    else if (calification >= 2 && calification < 3) {
        cout << "SOBRESALIENTE";
    }
    else if (calification >= 3) {
        cout << "BRILLANTE";
    }

    gotoxy(x+2, y+6);
    printBlinkingText(Despedida, x+3, y+9);

    _getch();
}

void Transition(int nivel) {
    cout << "";
    cout << "";
    cout << "";
    cout << "";
    cout << "";
    cout << "";
}

void Gratitude() {
    cout << "";
    cout << "";
    cout << "";
    cout << "";
    cout << "";
    cout << "";
}

string Name; // Nombre del Jugador
char O = 'O'; // Caracte para Heroe O

/*
Muñecos del Nivel 1
*/
// Posiciones iniciales de los muñecos A
int posXChars_A[numCharacters] = {};
int posYChars_A[numCharacters] = {};

// Posiciones iniciales de los muñecos X
int posXChars_X[numCharacters] = {};
int posYChars_X[numCharacters] = {};

// Posiciones iniciales de los muñecos W
int posXChars_W[numCharacters] = {};
int posYChars_W[numCharacters] = {};

// Posiciones iniciales de los muñecos K
int posXChars_K[numCharacters] = {};
int posYChars_K[numCharacters] = {};

char A = 'A'; // Caracter para Tutor A
char X = 'X'; // Caracter para Tutor X
char W = 'W'; // Caracter para Desafiante W
char K = 'K'; // Caracter para Desafiante K

/*
Muñecos del Nivel 2
*/
// Posiciones iniciales de los muñecos H
int posXChars_H[numCharacters] = {};
int posYChars_H[numCharacters] = {};

// Posiciones iniciales de los muñecos V
int posXChars_V[numCharacters] = {};
int posYChars_V[numCharacters] = {};

char H = 'H'; // Caracter para Tutor H
char V = 'V'; // Caracter para Enemigo V

/*
Muñecos del Nivel 3
*/
// Posiciones iniciales de los muñecos U
int posXChars_U[numCharacters] = {};
int posYChars_U[numCharacters] = {};
char U = 'U'; // Caracter para el Jefe Final



void BoardValidation1() {
    // Inicializamos el tablero con espacios en blanco y bordes
    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            // Dibujar bordes
            if (i == 0 || i == height - 1 || j == 0 || j == width - 1)
                board[i][j] = '#'; // Carácter para el borde
            else
                board[i][j] = ' '; // Espacio en blanco para el interior
        }
    }
    // Añadir obstáculos al tablero
    srand(time(0));
    int numObstacles = 300; // Número de obstáculos
    for (int i = 0; i < numObstacles; ++i) {
        int obsX, obsY;
        do {
            obsX = rand() % (width - 2) + 1; // Generar coordenada X aleatoria dentro del tablero
            obsY = rand() % (height - 2) + 1; // Generar coordenada Y aleatoria dentro del tablero
            validPosition = true;
            // Verificar que la posición no sea la inicial del muñeco O
            if (obsX == posX && obsY == posY) {
                validPosition = false;
            }
            else { // Verificar con
                for (int j = 0; j < numCharacters; ++j) {
                    if ((obsX == posXChars_A[j] && obsY == posYChars_A[j]) ||
                        (obsX == posXChars_X[j] && obsY == posYChars_X[j]) ||
                        (obsX == posXChars_W[j] && obsY == posYChars_W[j]) ||
                        (obsX == posXChars_K[j] && obsY == posYChars_K[j])) {
                        validPosition = false;
                        break;
                    }
                }
            }
        } while (!validPosition || board[obsY][obsX] != ' '); // Asegurarse de que el obstáculo no se coloque sobre otro obstáculo o muñeco
        board[obsY][obsX] = '#'; // Carácter para el obstáculo
    }
}

void BoardValidation2() {
    // Inicializamos el tablero con espacios en blanco y bordes
    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            // Dibujar bordes
            if (i == 0 || i == height - 1 || j == 0 || j == width - 1)
                board[i][j] = '#'; // Carácter para el borde
            else
                board[i][j] = ' '; // Espacio en blanco para el interior
        }
    }
    // Añadir obstáculos al tablero
    srand(time(0));
    int numObstacles = 300; // Número de obstáculos
    for (int i = 0; i < numObstacles; ++i) {
        int obsX, obsY;
        do {
            obsX = rand() % (width - 2) + 1; // Generar coordenada X aleatoria dentro del tablero
            obsY = rand() % (height - 2) + 1; // Generar coordenada Y aleatoria dentro del tablero
            validPosition = true;
            // Verificar que la posición no sea la inicial del muñeco O
            if (obsX == posX && obsY == posY) {
                validPosition = false;
            }
            else { // Verificar con
                for (int j = 0; j < numCharacters; ++j) {
                    if ((obsX == posXChars_H[j] && obsY == posYChars_H[j]) ||
                        (obsX == posXChars_V[j] && obsY == posYChars_V[j])) {
                        validPosition = false;
                        break;
                    }
                }
            }
        } while (!validPosition || board[obsY][obsX] != ' '); // Asegurarse de que el obstáculo no se coloque sobre otro obstáculo o muñeco
        board[obsY][obsX] = '#'; // Carácter para el obstáculo
    }
}

void BoardValidation3() {
    // Inicializamos el tablero con espacios en blanco y bordes
    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            // Dibujar bordes
            if (i == 0 || i == height - 1 || j == 0 || j == width - 1)
                board[i][j] = '#'; // Carácter para el borde
            else
                board[i][j] = ' '; // Espacio en blanco para el interior
        }
    }
    // Añadir obstáculos al tablero
    srand(time(0));
    int numObstacles = 300; // Número de obstáculos
    for (int i = 0; i < numObstacles; ++i) {
        int obsX, obsY;
        do {
            obsX = rand() % (width - 2) + 1; // Generar coordenada X aleatoria dentro del tablero
            obsY = rand() % (height - 2) + 1; // Generar coordenada Y aleatoria dentro del tablero
            validPosition = true;
            // Verificar que la posición no sea la inicial del muñeco O
            if (obsX == posX && obsY == posY) {
                validPosition = false;
            }
            else { // Verificar con
                for (int j = 0; j < numCharacters; ++j) {
                    if (obsX == posXChars_U[j] && obsY == posYChars_U[j]) {
                        validPosition = false;
                        break;
                    }
                }
            }
        } while (!validPosition || board[obsY][obsX] != ' '); // Asegurarse de que el obstáculo no se coloque sobre otro obstáculo o muñeco
        board[obsY][obsX] = '#'; // Carácter para el obstáculo
    }
}

void CharactersValidation1() {
    for (int i = 0; i < numCharacters; ++i) {
        bool validPosition = false;
        do {
            // Generar coordenadas aleatorias dentro del tablero
            posXChars_A[i] = randnum(1, width - 2);
            posYChars_A[i] = randnum(1, height - 2);
            posXChars_X[i] = randnum(1, width - 2);
            posYChars_X[i] = randnum(1, height - 2);
            posXChars_W[i] = randnum(1, width - 2);
            posYChars_W[i] = randnum(1, height - 2);
            posXChars_K[i] = randnum(1, width - 2);
            posYChars_K[i] = randnum(1, height - 2);

            // Verificar que la posición no sea una ocupada
            if ((posXChars_A[i] != posXChars_X[i] || posYChars_A[i] != posYChars_X[i]) &&
                (posXChars_A[i] != posXChars_W[i] || posYChars_A[i] != posYChars_W[i]) &&
                (posXChars_A[i] != posXChars_K[i] || posYChars_A[i] != posYChars_K[i]) &&
                (posXChars_X[i] != posXChars_W[i] || posYChars_X[i] != posYChars_W[i]) &&
                (posXChars_X[i] != posXChars_K[i] || posYChars_X[i] != posYChars_K[i]) &&
                (posXChars_W[i] != posXChars_K[i] || posYChars_W[i] != posYChars_K[i]) &&
                board[posYChars_A[i]][posXChars_A[i]] == ' ' &&
                board[posYChars_X[i]][posXChars_X[i]] == ' ' &&
                board[posYChars_W[i]][posXChars_W[i]] == ' ' &&
                board[posYChars_K[i]][posXChars_K[i]] == ' ') {
                validPosition = true;
            }
            else {
                validPosition = false;
            }
        } while (!validPosition); // Asegurarse de que el obstáculo no se coloque sobre otro obstáculo o muñeco
    }
}

void CharactersValidation2() {
    for (int i = 0; i < numCharacters; ++i) {
        bool validPosition = false;
        do {
            // Generar coordenadas aleatorias dentro del tablero
            posXChars_H[i] = randnum(1, width - 2);
            posYChars_H[i] = randnum(1, height - 2);
            posXChars_V[i] = randnum(1, width - 2);
            posYChars_V[i] = randnum(1, height - 2);

            // Verificar que la posición no sea una ocupada
            if ((posXChars_H[i] != posXChars_V[i] || posYChars_H[i] != posYChars_V[i]) &&
                board[posYChars_H[i]][posXChars_H[i]] == ' ' &&
                board[posYChars_V[i]][posXChars_V[i]] == ' ') {
                validPosition = true;
            }
            else {
                validPosition = false;
            }
        } while (!validPosition); // Asegurarse de que el obstáculo no se coloque sobre otro obstáculo o muñeco
    }
}

void CharactersValidation3() {
    for (int i = 0; i < numCharacters; ++i) {
        bool validPosition = false;
        do {
            // Generar coordenadas aleatorias dentro del tablero
            posXChars_U[i] = randnum(1, width - 2);
            posYChars_U[i] = randnum(1, height - 2);

            // Verificar que la posición no sea una ocupada
            if (board[posYChars_U[i]][posXChars_U[i]] == ' ') {
                validPosition = true;
            }
            else {
                validPosition = false;
            }
        } while (!validPosition); // Asegurarse de que el obstáculo no se coloque sobre otro obstáculo o muñeco
    }
}

int Level = 0; // Nivel
float Calification = 0; // Calificacion del Jugador

/*
Juego 1
*/
void GamePlay1() {
    while (Points < 100 && Points > 0) {
        // Dibujar personajes en el tablero
        for (int i = 0; i < numCharacters; ++i) {
            board[posYChars_A[i]][posXChars_A[i]] = A;
            board[posYChars_X[i]][posXChars_X[i]] = X;
            board[posYChars_W[i]][posXChars_W[i]] = W;
            board[posYChars_K[i]][posXChars_K[i]] = K;
        }
        board[posY][posX] = O; // Dibujar el personaje principal
        clearScreen();
        setColor(6, 0);
        PuntajeHeroe(1, 26, Points);
        NumVisitsTutor(1, 27, TutorVisits);
        NumVisitsEnemy(1, 28, EnemyVisits);
        Hero(Level, 70, 27, Name);
        setColor(0, 3);
        // Imprimimos el tablero
        for (int i = 0; i < height; ++i) {
            for (int j = 0; j < width; ++j) {
                cout << board[i][j] << " ";
            }
            cout << endl;
        }
        resetColor();

        board[posY][posX] = ' '; // Limpiamos la posición actual de Heroe

        // Limpiamos las posiciones anteriores de los muñecos
        for (int i = 0; i < numCharacters; ++i) {
            board[posYChars_A[i]][posXChars_A[i]] = ' ';
            board[posYChars_X[i]][posXChars_X[i]] = ' ';
            board[posYChars_W[i]][posXChars_W[i]] = ' ';
            board[posYChars_K[i]][posXChars_K[i]] = ' ';
        }

        // Capturamos la entrada
        char input = toupper(_getch());

        // Movemos al muñeco O según la entrada, asegurándonos de no colisionar con los bordes ni con los obstáculos
        switch (input) {
        case 'W':
            if (posY > 1 && board[posY - 1][posX] == ' ') posY--; // Mover arriba si no está en el borde superior o hay un obstáculo
            break;
        case 'A':
            if (posX > 1 && board[posY][posX - 1] == ' ') posX--; // Mover izquierda si no está en el borde izquierdo o hay un obstáculo
            break;
        case 'S':
            if (posY < height - 2 && board[posY + 1][posX] == ' ') posY++; // Mover abajo si no está en el borde inferior o hay un obstáculo
            break;
        case 'D':
            if (posX < width - 2 && board[posY][posX + 1] == ' ') posX++; // Mover derecha si no está en el borde derecho o hay un obstáculo
            break;
        }
        // Mover personajes
        moveCharacters(board, posYChars_A, posXChars_A);
        moveCharacters(board, posYChars_X, posXChars_X);
        moveCharacters(board, posYChars_W, posXChars_W);
        moveCharacters(board, posYChars_K, posXChars_K);

        // Verificar si el muñeco O está en la posición de algún muñeco A, X, W o K para mostrar tutoriales
        for (int i = 0; i < numCharacters; ++i) {
            if (posX == posXChars_A[i] && posY == posYChars_A[i]) {
                showPythagorasTutorial_A(); // Mostrar Tutorial de Pitagoras al colisionar
                TutorVisits++; Points-=2;
            }
            if (posX == posXChars_X[i] && posY == posYChars_X[i]) {
                showEquationsTutorial_X(); // Mostrar Tutorial de Ecuaciones al colisionar
                TutorVisits++; Points-=2;
            }
            if (posX == posXChars_W[i] && posY == posYChars_W[i]) {
                showPythagorasChallenge_W(); // Mostrar Desafio de Pitagoras al colisionar
                EnemyVisits++;
            }
            if (posX == posXChars_K[i] && posY == posYChars_K[i]) {
                showEquationsChallenge_K(); // Mostrar Desafio de Ecuaciones al colisionar
                EnemyVisits++;
            }
        }
    }
    if (Points <= 0) {
        Calification = 0;
        postCredits(Name, Level, 42, 10, Calification, TutorVisits, EnemyVisits); // Mostrar creditos si el Heroe tiene como Puntaje 0
        exit(0);
    }
    else if (Points >= 100) {
        Calification += Points/100;
        Level++;
        Points = 25;
    }
}

/*
Juego 2
*/
void GamePlay2() {
    while (Points < 100 && Points > 0) {
        // Dibujar personajes en el tablero
        for (int i = 0; i < numCharacters; ++i) {
            board[posYChars_H[i]][posXChars_H[i]] = H;
            board[posYChars_V[i]][posXChars_V[i]] = V;
        }
        board[posY][posX] = O; // Dibujar el personaje principal

        clearScreen();
        setColor(15, 0);
        PuntajeHeroe(1, 26, Points);
        NumVisitsTutor(1, 27, TutorVisits);
        NumVisitsEnemy(1, 28, EnemyVisits);
        Hero(Level, 70, 27, Name);
        setColor(5, 14);
        // Imprimimos el tablero
        for (int i = 0; i < height; ++i) {
            for (int j = 0; j < width; ++j) {
                cout << board[i][j] << " ";
            }
            cout << endl;
        }
        resetColor(); // Restaurar el color

        board[posY][posX] = ' '; // Limpiamos la posición actual de Heroe

        // Limpiamos las posiciones anteriores de los muñecos
        for (int i = 0; i < numCharacters; ++i) {
            board[posYChars_H[i]][posXChars_H[i]] = ' ';
            board[posYChars_V[i]][posXChars_V[i]] = ' ';
        }

        // Capturamos la entrada
        char input = toupper(_getch());

        // Movemos al muñeco O según la entrada, asegurándonos de no colisionar con los bordes ni con los obstáculos
        switch (input) {
        case 'W':
            if (posY > 1 && board[posY - 1][posX] == ' ') posY--; // Mover arriba si no está en el borde superior o hay un obstáculo
            break;
        case 'A':
            if (posX > 1 && board[posY][posX - 1] == ' ') posX--; // Mover izquierda si no está en el borde izquierdo o hay un obstáculo
            break;
        case 'S':
            if (posY < height - 2 && board[posY + 1][posX] == ' ') posY++; // Mover abajo si no está en el borde inferior o hay un obstáculo
            break;
        case 'D':
            if (posX < width - 2 && board[posY][posX + 1] == ' ') posX++; // Mover derecha si no está en el borde derecho o hay un obstáculo
            break;
        }

        // Mover personajes
        moveCharacters(board, posYChars_H, posXChars_H);
        moveCharacters(board, posYChars_V, posXChars_V);

        // Verificar si el muñeco O está en la posición de algún muñeco A, X, W o K para mostrar tutoriales
        for (int i = 0; i < numCharacters; ++i) {
            if (posX == posXChars_H[i] && posY == posYChars_H[i]) {
                showTutorial_H(); // Mostrar Tutorial al colisionar
                TutorVisits++;
            }
            if (posX == posXChars_V[i] && posY == posYChars_V[i]) {
                showChallenge_V(); // Mostrar Desafio al colisionar
                EnemyVisits++;
            }
        }
    }
    if (Points <= 0) {
        postCredits(Name, Level, 42, 10, Calification, TutorVisits, EnemyVisits); // Mostrar creditos si el Heroe tiene como Puntaje 0
        exit(0);
    }
    else if (Points >= 100) {
        Calification += Points / 100;
        Level++;
        Points = 25;
    }
}

/*
Juego 3
*/
void GamePlay3() {
    resetColor();
    while (Points < 100 && Points > 0) {
        // Dibujar personajes en el tablero
        for (int i = 0; i < numCharacters; ++i) {
            board[posYChars_U[i]][posXChars_U[i]] = U;
        }
        board[posY][posX] = O; // Dibujar el personaje principal

        clearScreen();
        setColor(15, 0);
        PuntajeHeroe(1, 26, Points);
        NumVisitsTutor(1, 27, TutorVisits);
        NumVisitsEnemy(1, 28, EnemyVisits);
        Hero(Level, 70, 27, Name);
        setColor(4, 15);
        // Imprimimos el tablero
        for (int i = 0; i < height; ++i) {
            for (int j = 0; j < width; ++j) {
                cout << board[i][j] << " ";
            }
            cout << endl;
        }
        resetColor(); // Restablecer el color después de imprimir el tablero

        board[posY][posX] = ' '; // Limpiamos la posición actual de Heroe

        // Limpiamos las posiciones anteriores de los muñecos
        for (int i = 0; i < numCharacters; ++i) {
            board[posYChars_U[i]][posXChars_U[i]] = ' ';
        }

        // Capturamos la entrada
        char input = toupper(_getch());

        // Movemos al muñeco O según la entrada, asegurándonos de no colisionar con los bordes ni con los obstáculos
        switch (input) {
        case 'W':
            if (posY > 1 && board[posY - 1][posX] == ' ') posY--; // Mover arriba si no está en el borde superior o hay un obstáculo
            break;
        case 'A':
            if (posX > 1 && board[posY][posX - 1] == ' ') posX--; // Mover izquierda si no está en el borde izquierdo o hay un obstáculo
            break;
        case 'S':
            if (posY < height - 2 && board[posY + 1][posX] == ' ') posY++; // Mover abajo si no está en el borde inferior o hay un obstáculo
            break;
        case 'D':
            if (posX < width - 2 && board[posY][posX + 1] == ' ') posX++; // Mover derecha si no está en el borde derecho o hay un obstáculo
            break;
        }

        // Mover personajes
        moveCharacters(board, posYChars_U, posXChars_U);

        // Verificar si el muñeco O está en la posición de algún muñeco A, X, W o K para mostrar tutoriales
        for (int i = 0; i < numCharacters; ++i) {
            if (posX == posXChars_U[i] && posY == posYChars_U[i]) {
                showFinalChallenge_U(); // Mostrar Desafio Final
                EnemyVisits++;
            }
        }
    }
    if (Points <= 0) {
        postCredits(Name, Level, 42, 10, Calification, TutorVisits, EnemyVisits); // Mostrar creditos si el Heroe tiene como Puntaje 0
        exit(0);
    }
    else if (Points >= 100) {
        Calification += Points / 100;
        Level++;
        postCredits(Name, Level, 42, 10, Calification, TutorVisits, EnemyVisits); // Mensaje Ganador
    }
}

void MathWorld() {
    hideCursor(); // Ocultar el cursor
    srand(time(0)); // Semilla para los números aleatorios
    Welcome(); // Bienvenida
    Menu(); // Menu
    
    cout << "Ingresa tu nombre: ";
    cin >> Name;

    /*
    Juego
    */
    BoardValidation1(); // Validacion del Tablero
    CharactersValidation1(); // Validacion de los Personajes
    Transition(Level); // Transición
    GamePlay1(); // Juego 1
    BoardValidation2(); // Validacion del Tablero
    CharactersValidation2(); // Validacion de los Personajes
    Transition(Level); // Transición
    GamePlay2(); // Juego 2
    BoardValidation3(); // Validacion del Tablero
    CharactersValidation3(); // Validacion de los Personajes
    Transition(Level); // Transición
    GamePlay3(); // Juego 3
    Gratitude(); // Despedida
}

/*
Funcion Principal
*/
int main() {
    MathWorld();
    return 0;
}
